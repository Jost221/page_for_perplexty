Тес­ти­рова­ние по тре­бова­ни­ям бе­зопас­ности — это про­цесс вы­яв­ле­ния на­личия или от­сутс­твия у­яз­ви­мос­тей в про­дук­те в ис­кусс­твен­но соз­данных си­ту­аци­ях и на ог­ра­ничен­ном на­боре тес­тов, выб­ранных оп­ре­делен­ным об­ра­зом.

Тес­ти­ровать ПО (см. под­разд. 1.7) не­об­хо­димо на на­личие в нем сиг­на­тур, на­руша­ющих его фун­кци­ональность.

При тес­ти­рова­нии по тре­бова­ни­ям бе­зопас­ности про­водят­ся сле­ду­ющие ис­пы­тания:

а­удит бе­зопас­ности ко­да, нап­равлен­ный на вы­яв­ле­ние у­яз­ви­мос­тей;
фун­кци­ональное тес­ти­рова­ние — про­вер­ка ха­рак­те­рис­тик бе­зопас­ности ПО;
эк­спе­римен­тальное тес­ти­рова­ние — про­вер­ка на воз­можность экс­плу­ата­ции об­на­ружен­ных сиг­на­тур.
Су­щес­тву­ют руч­ной, ста­тичес­кий (по шаб­ло­ну) и ди­нами­чес­кий при­емы вы­яв­ле­ния у­яз­ви­мос­тей.

При руч­ном под­хо­де при­меня­ет­ся эк­спертный ана­лиз, при ко­тором спе­ци­алист, про­водя­щий дан­ное ис­сле­дова­ние, по­лага­ет­ся на свои зна­ния и опыт. Дан­ный под­ход не под­ра­зуме­ва­ет ис­пользо­вания ка­ких-ли­бо ав­то­мати­зиро­ван­ных средств. Этот при­ем име­ет большие зат­ра­ты по вре­мени и пред­по­лага­ет на­личие спе­ци­алис­тов вы­сокой ква­лифи­кации. Та­кой под­ход счи­та­ет­ся са­мым эф­фектив­ным с точ­ки зре­ния точ­ности и пол­но­ты пок­ры­тия про­верок.

Вы­яв­ле­ние у­яз­ви­мос­тей по шаб­ло­ну под­ра­зуме­ва­ет ис­пользо­вание ма­тери­алов и на­рабо­ток, по­лучен­ных ис­хо­дя из опы­та ра­боты в дан­ной об­ласти. Здесь воз­мо­жен ав­то­мати­зиро­ван­ный под­ход по­ис­ка у­яз­ви­мос­тей по за­дан­ным шаб­ло­нам (спис­кам по­тен­ци­ально опас­ных сиг­на­тур). Воз­можно так­же сов­ме­щение ме­тодов ав­то­мати­зиро­ван­но­го и руч­но­го по­ис­ка у­яз­ви­мос­тей. Ос­новной проб­ле­мой здесь яв­ля­ет­ся соз­да­ние стан­дар­тных спис­ков по­тен­ци­ально опас­ных сиг­на­тур. Мож­но вос­пользо­ваться по­ложи­тельной прак­ти­кой, уже су­щес­тву­ющей в меж­ду­народ­ных про­ек­тах CWE, ли­бо из­вес­тным ре­сур­сом для веб-при­ложе­ний OWASP.

Ди­нами­чес­кий ана­лиз яв­ля­ет­ся обя­зательным под­хо­дом при вы­яв­ле­нии у­яз­ви­мос­тей. Он поз­во­ля­ет про­водить тес­ти­рова­ние при не­пос­редс­твен­ном вы­пол­не­нии прог­рам­мно­го из­де­лия. В про­цес­се ди­нами­чес­ко­го тес­ти­рова­ния прог­рам­мно­го про­дук­та ре­али­зу­ет­ся сос­тавлен­ный спи­сок тес­тов, нап­равлен­ный на дос­ти­жение ли­бо про­вал на­руше­ния функ­ций бе­зопас­ности про­дук­та, т. е. оп­ре­деля­ет­ся воз­можность или не­воз­можность экс­плу­ати­ровать найден­ную по­тен­ци­ально опас­ную сиг­на­туру в рам­ках ра­бота­юще­го прог­рам­мно­го про­дук­та при за­дан­ном тес­то­вом ок­ру­жении.

Тра­дици­он­ные ме­тоды тес­ти­рова­ния. Глав­ным от­ли­чи­ем при тес­ти­рова­нии по тре­бова­ни­ям без­опас­ности яв­ля­ет­ся то, что мы ищем не ошиб­ки (bugs), а у­яз­ви­мос­ти, ве­дущие к на­руше­нию це­лост­нос­ти, кон­фи­ден­ци­альнос­ти и дос­тупнос­ти. Глу­бина тес­ти­рова­ния оп­ре­деля­ет­ся сле­ду­ющи­ми уров­ня­ми тес­ти­рова­ния: мо­дульное, ин­тегра­ци­он­ное и сис­темное.

Уро­вень мо­дульно­го тес­ти­рова­ния поз­во­ля­ет про­верить фун­кци­они­рова­ние от­дельно взя­того эле­мен­та сис­те­мы. Что счи­тать эле­мен­том (мо­дулем) сис­те­мы оп­ре­деля­ет­ся кон­тек­стом. На­ибо­лее пол­но дан­ный вид тес­тов опи­сан в стан­дарте IEEE 1008—87 «Standard for Software Unit Testing», за­да­ющем ин­тегри­рован­ную кон­цепцию сис­те­мати­чес­ко­го и до­кумен­ти­рован­но­го под­хо­да к мо­дульно­му тес­ти­рова­нию.

Ин­тегра­ци­он­ное тес­ти­рова­ние — это про­цесс про­вер­ки вза­имо­действия меж­ду прог­рам­мны­ми ком­по­нен­та­ми/мо­дуля­ми.

Клас­си­чес­кие стра­тегии ин­тегра­ци­он­но­го тес­ти­рова­ния — «свер­ху вниз» и «сни­зу вверх» — ис­пользу­ют­ся для тра­дици­он­ных, и­ерар­хи­чес­ки струк­ту­риро­ван­ных сис­тем и их слож­но при­менять, на­при­мер, к тес­ти­рова­нию сла­бос­вя­зан­ных сис­тем, пос­тро­ен­ных в сер­висно-ори­ен­ти­рован­ных ар­хи­тек­ту­рах (SOA).

Сис­темное тес­ти­рова­ние ох­ва­тыва­ет це­ликом всю сис­те­му. Большинс­тво фун­кцио­нальных сбо­ев дол­жно быть иден­ти­фици­рова­но еще на уров­не мо­дульных и ин­тегра­ци­он­ных тес­тов. В свою оче­редь, сис­темное тес­ти­рова­ние обыч­но фо­куси­ру­ет­ся на не­функ­ци­ональных тре­бова­ни­ях — бе­зопас­ности, про­из­во­дительнос­ти, точ­ности, на­деж­ности и др. На этом уров­не так­же тес­ти­ру­ют­ся ин­терфейсы к внеш­ним при­ложе­ни­ям, ап­па­рат­но­му обес­пе­чению, опе­раци­он­ной сре­де и т. д.

Ви­ды тес­ти­рова­ния. Это — еще один спо­соб клас­си­фика­ции про­цес­сов тес­ти­рова­ния по кри­терию бе­зопас­ности. Рас­смот­рим ос­новные из них.

При при­емоч­ном тес­ти­рова­нии про­веря­ет­ся по­веде­ние сис­те­мы на пред­мет удов­летво­рения тре­бова­ний за­каз­чи­ка.

Ус­та­новоч­ное тес­ти­рова­ние про­водят в це­лях про­вер­ки про­цеду­ры ин­стал­ля­ции сис­те­мы в це­левом ок­ру­жении.

Альфа- и бе­та-тес­ти­рова­ния под­ра­зуме­ва­ют со­от­ветс­твен­но про­веде­ние внут­ренне­го проб­но­го ис­пользо­вания ПО (альфа) и проб­но­го ис­пользо­вания ПО с прив­ле­чени­ем вер­сий ПО, отоб­ранных внеш­ни­ми пользо­вате­лями (бе­та). Дан­ные тес­ти­рова­ния до­кумен­ти­ру­ют­ся над­ле­жащим об­ра­зом.

Фун­кци­ональное и рег­ресси­он­ное тес­ти­рова­ния опи­саны ра­нее (см. под­разд. 1.7).

В про­цес­се тес­ти­рова­ния по кри­терию на­деж­ности ге­нери­ру­ют­ся слу­чайные на­боры вход­ных дан­ных для ПО. По­лучен­ные по ито­гам тес­ти­рова­ния дан­ные по сбо­ям и от­ка­зам ПО под­верга­ют­ся ста­тис­ти­чес­кой об­ра­бот­ке, ре­зульта­том ко­торой яв­ля­ют­ся рас­четные по­каза­тели на­деж­ности ПО.

Тес­ти­рова­ние про­из­во­дительнос­ти под­ра­зуме­ва­ет ис­пользо­вание спе­ци­али­зиро­ван­ных тес­тов, обес­пе­чива­ющих дос­ти­жение ко­личес­твен­ных пре­делов, обус­ловлен­ных ха­рак­те­рис­ти­ками са­мой сис­те­мы и ее опе­раци­он­но­го ок­ру­жения.

Наг­ру­зоч­ное тес­ти­рова­ние от­ли­чат­ся от пре­дыду­щего тем, что здесь про­цесс наг­ру­жения на тес­ти­ру­емую сис­те­му про­ис­хо­дит по­этап­но от ми­нимальной до мак­си­мальной ве­личи­ны (оп­ре­делен­ной на эта­пе тес­ти­рова­ния про­из­во­дительнос­ти), при­чем ре­зульта­ты тес­ти­рова­ния фик­си­ру­ют­ся на каж­дом эта­пе.

Срав­ни­тельное тес­ти­рова­ние пред­по­лага­ет под­го­тов­ку еди­нич­но­го на­бора тес­тов, поз­во­ля­юще­го срав­нить две вер­сии сис­те­мы.

Вос­ста­нови­тельные тес­ты вы­пол­ня­ют­ся для оцен­ки воз­можнос­тей рес­тарта сис­те­мы в слу­чае неп­ре­дус­мотрен­ной ка­тас­тро­фы, вли­яющей на фун­кци­они­рова­ние опе­раци­он­ной сре­ды, в ко­торой вы­пол­ня­ет­ся сис­те­ма.

Кон­фи­гура­ци­он­ное тес­ти­рова­ние при­меня­ет­ся в тех слу­ча­ях, ког­да ПО соз­да­ет­ся для ис­пользо­вания раз­личны­ми пользо­вате­лями. Дан­ный вид тес­ти­рова­ния нап­равлен на про­вер­ку по­веде­ния и ра­ботос­по­соб­ности сис­те­мы в раз­личных кон­фи­гура­ци­ях.

Тес­ти­рова­ние удобс­тва и прос­то­ты ис­пользо­вания про­водит­ся, что­бы про­верить, нас­колько лег­ко ко­неч­ный пользо­ватель сис­те­мы мо­жет ее ос­во­ить, вклю­чая не только фун­кци­ональную сос­тавля­ющую сис­те­мы, но и ее до­кумен­та­цию.

Тех­ни­ки, ори­ен­ти­рован­ные на код (Code-based techniques):

тес­ты, ба­зиру­ющи­еся на блок-схе­ме (Control-flow-based criteria). На­бор тес­тов стро­ит­ся ис­хо­дя из пок­ры­тия всех ус­ло­вий и ре­шений блок-схе­мы. В ка­кой-то сте­пени на­поми­на­ет тес­ты на ос­но­ве ко­неч­но­го ав­то­мата. От­ли­чие — в ис­точни­ке на­бора тес­тов. Мак­си­мальная от­да­ча от тес­тов на ос­но­ве блок-схе­мы по­луча­ет­ся, ког­да тес­ты пок­ры­ва­ют раз­личные пу­ти блок-схе­мы — по су­ти, сце­нарии по­токов ра­бот (по­веде­ния) тес­ти­ру­емой сис­те­мы. Адек­ватность та­ких тес­тов оце­нива­ет­ся как про­цент пок­ры­тия всех воз­можных пу­тей блок-схе­мы;
тес­ты на ос­но­ве по­токов дан­ных, ко­торые от­сле­жива­ют пол­ный ЖЦ ве­личин (пе­ремен­ных) с мо­мен­та их оп­ре­деле­ния, на всем про­тяже­нии ис­пользо­вания, вплоть до унич­то­жения (не­оп­ре­делен­ности). В ре­альной прак­ти­ке ис­пользу­ют­ся нес­тро­гое тес­ти­рова­ние та­кого ви­да, ори­ен­ти­рован­ное, нап­ри­мер, только на про­вер­ку за­дания на­чальных зна­чений всех пе­ремен­ных или всех вхож­де­ний пе­ремен­ных в код, с точ­ки зре­ния их ис­пользо­вания.
Об­зор средств вы­яв­ле­ния у­яз­ви­мос­тей. Су­щес­тву­ет ряд средств ав­то­мати­зации вы­яв­ле­ния у­яз­ви­мос­тей, ко­торые мо­гут быть ис­пользо­ваны при ста­тичес­ком ана­лизе без­опас­ности на уров­не ко­да по шаб­ло­ну (табл. 6.2). Кро­ме инос­тран­ных средств про­вер­ки здесь пред­став­ле­ны и рос­сийские раз­ра­бот­ки, ре­али­зован­ные на вы­соком тех­ни­чес­ком и про­фес­си­ональном уров­не.

Таблица 6.2. Обзор средств выявления уязвимостей, работающих на уровне кода
Средс­тво	Наз­на­чение	Под­дер-
жи­ва­емые язы­ки про-
грам­ми­ро-
ва­ния	При­меча­ние
Инос­тран­ные средс­тва вы­яв­ле­ния у­яз­ви­мос­тей
BOON	На ос­но­ве глу­боко­го се­ман­ти­чес­ко­го ана­лиза ав­то­мати­зиру­ет про­цесс ска­ниро­вания ис­ходных тек­стов на Си в по­ис­ках у­яз­ви­мых мест	С	Вы­яв­ля­ет воз­можные де­фек­ты, пред­по­лагая, что не­кото­рые зна­чения яв­ля­ют­ся частью не­яв­но­го ти­па с кон­крет­ным раз­ме­ром бу­фера
CQual	Рас­ши­ря­ет язык Си до­пол­ни­тельны­ми оп­ре­деля­емы­ми пользо­вате­лем спе­ци­фика­тора­ми ти­па, поз­во­ляя об­на­ружи­вать ошиб­ки в прог­раммах	С	Мо­жет ис­пользо­ваться, что­бы об­на­ружить по­тен­ци­альную у­яз­ви­мость фор­матной стро­ки
MOPS (Mоdel checking Programs for Security)	Да­ет воз­можность ди­нами­чес­кой кор­ректи­ров­ки, обес­пе­чива­ющей со­от­ветс­твие прог­раммы на Си ста­тичес­кой мо­дели	С	Ис­пользу­ет мо­дель а­уди­та ПО, ко­торая приз­ва­на по­мочь вы­яс­нить, со­от­ветс­тву­ет ли прог­рамма на­бору пра­вил, оп­ре­делен­но­му для соз­да­ния бе­зопас­ных прог­рамм
ITS4	Ста­тичес­ки прос­матри­ва­ет ис­ходный код для об­на­руже­ния по­тен­ци­альных у­яз­ви­мос­тей за­щиты	С/С++	От­ме­ча­ет вы­зовы по­тен­ци­ально опас­ных фун­кций, та­ких как strcpy/memcpy, и вы­пол­ня­ет по­верх­нос­тный се­ман­ти­чес­кий ана­лиз, пы­та­ясь оце­нить, нас­колько опа­сен та­кой код, а так­же да­ет со­веты по его улуч­ше­нию
RATS (Rough Auditing Tool for Security)	Прос­матри­ва­ет ис­ходный текст, на­ходя по­тен­ци­ально опас­ные об­ра­щения к фун­кци­ям	С/С++, PHP, Perl, Python	Ис­пользу­ет со­чета­ние про­верок на­деж­ности за­щиты от се­ман­ти­чес­ких про­верок в ITS4 до глу­боко­го се­ман­ти­чес­ко­го ана­лиза в по­ис­ках де­фек­тов, спо­соб­ных при­вес­ти к пе­репол­не­нию бу­фера, по­лучен­ных из MOPS
PScan	Ста­тичес­ки прос­матри­ва­ет ис­ходный код для об­на­руже­ния по­тен­ци­альных у­яз­ви­мос­тей за­щиты	C	Ска­ниру­ет ис­ходные тек­сты на язы­ке Си в по­ис­ках по­тен­ци­ально не­кор­рек­тно­го ис­пользо­вания фун­кций, ана­логич­ных printf, и вы­яв­ля­ет у­яз­ви­мые мес­та в стро­ках фор­ма­та
Flawfinder	Прос­матри­ва­ет ис­ходный текст, на­ходя по­тен­ци­ально опас­ные об­ра­щения к фун­кци­ям	С/С++	Вы­пол­ня­ет по­иск фун­кций, ко­торые ча­ще все­го ис­пользу­ют­ся не­кор­рек­тно, прис­ва­ива­ет им ко­эф­фи­ци­ен­ты рис­ка (опи­ра­ясь на та­кую ин­форма­цию, как пе­реда­ва­емые па­рамет­ры) и сос­тавля­ет спи­сок по­тен­ци­ально у­яз­ви­мых мест, упо­рядо­чивая их по сте­пени рис­ка
Bunch	Яв­ля­ет­ся средс­твом ана­лиза и ви­зу­али­зации про­грамм на Си	С	Стро­ит граф за­виси­мос­тей, по­мога­ющий а­уди­тору ра­зоб­раться в мо­дульной струк­ту­ре прог­раммы
UNO	На­ходит та­кие ошиб­ки, как не­ини­ци­али­зиро­ван­ные пе­ремен­ные, ну­левые ука­зате­ли и вы­ход за пре­делы мас­си­ва	С	Поз­во­ля­ет вы­пол­нять нес­ложный ана­лиз по­тока уп­равле­ния и по­токов дан­ных, осу­щест­влять как внут­рипро­цедур­ный, так и меж­про­цедур­ный ана­лиз, спе­цифи­циро­вать свойства пользо­вате­ля
FlexeLint (PC-Lint)	Про­из­во­дит се­ман­ти­чес­кий ана­лиз ис­ходно­го ко­да, ана­лиз по­токов дан­ных и уп­равле­ния	С/С++	В кон­це ра­боты вы­да­ет со­об­ще­ния нес­кольких ос­новных ти­пов: воз­мо­жен ну­левой ука­затель; проб­ле­мы с вы­деле­ни­ем па­мяти (нап­ри­мер, нет free( ) пос­ле malloc( )); проб­лемный по­ток уп­равле­ния (нап­ри­мер, не­дос­ти­жимый код); воз­можно пе­репол­не­ние бу­фера, ариф­ме­тичес­кое пе­репол­не­ние; пре­дуп­режде­ния о пло­хом и по­тен­ци­ально опас­ном сти­ле ко­да
Parasoft C++ Test	Фор­ми­ру­ет тес­ты ана­лиза у­яз­ви­мос­тей на уров­не ме­тода, клас­са, файла и про­ек­та	С++	Ге­нери­ру­ет тес­то­вый код, вы­зывая для его под­го­тов­ки ком­пи­лятор Visual C++
Coverity	Ис­пользу­ет­ся для вы­яв­ле­ния и ис­прав­ле­ния де­фек­тов бе­зопас­ности и ка­че­ства в при­ложе­ни­ях кри­тичес­ко­го наз­на­чения	С/С++, Java	Спо­соб­но с ми­нимальной по­ложи­тельной пог­решностью об­ра­баты­вать де­сят­ки мил­ли­онов строк ко­да, обес­пе­чивая 100%-е пок­ры­тие трас­сы
KlocWork K7	Пред­назна­чено для ав­то­мати­зиро­ван­но­го ста­тичес­ко­го ана­лиза ко­да, вы­яв­ле­ния и пре­дот­вра­щения де­фек­тов ПО и проб­лем без­опас­ности	С/С++, Java	Вы­яв­ля­ет ко­рен­ные при­чины
не­дос­татков ка­чес­тва и бе­зопас­ности ПО
Frama-C	Ана­лизи­ру­ет ис­ходный код на язы­ке Си	С	Вклю­ча­ет в се­бя ACSL (ANSI/ISO C Specification Language) — спе­ци­альный язык, поз­во­ля­ющий под­робно опи­сывать спе­цифи­кации фун­кций Си, нап­ри­мер, ука­зать ди­апа­зон до­пус­ти­мых вход­ных зна­чений функ­ции и ди­апа­зон нор­мальных вы­ход­ных зна­чений
CodeSurfer	Мо­жет при­меняться для по­ис­ка оши­бок в ис­ходном ко­де, для улуч­ше­ния по­нима­ния ис­ходно­го ко­да	С/С++	Поз­во­ля­ет про­водить ана­лиз ука­зате­лей, ис­пользо­вать и оп­ре­делять пе­ремен­ные, за­виси­мос­ти дан­ных, стро­ить гра­фы вы­зовов
FxCop	Спо­соб­но об­на­ружить бо­лее 200 не­доче­тов (или оши­бок) в сле­ду­ющих об­ластях: ар­хи­тек­ту­ра; биб­ли­оте­ки; пра­вила име­нова­ния; про­из­во­дительность; бе­зопас­ность	С/С++	Про­веря­ет от­компи­лиро­ван­ный код с по­мощью ме­ханиз­мов реф­лексии, пар­синга MSIL и ана­лиза гра­фа вы­зовов
JavaChecker	Поз­во­ля­ет вы­яв­лять сле­ду­ющие де­фек­ты ко­да: неб­режная об­ра­бот­ка ис­клю­чений (пус­тые catch-бло­ки); сок­ры­тие имен; на­руше­ния сти­ля; на­руше­ния стан­дар­тных кон­трак­тов; на­руше­ния ис­пользо­вания (нап­ри­мер, ког­да пе­ре­оп­ре­делен ме­тод equals,
но не hashCode); на­руше­ния син­хро­низа­ции	Java	По су­ти, яв­ля­ет­ся ста­тичес­ким ана­лиза­тором Java-прог­рамм, ос­но­ван­ным на тех­но­логии TermWare
Simian	Про­водит быс­трый по­иск дуб­ли­ру­ющих­ся фраг­ментов ко­да во мно­гих файлах од­новре­мен­но	C#, T-SQL, JavaScript и Visual Basic R	По­мога­ет сох­ра­нить це­лос­тность и эф­фектив­ность про­дук­та
RPVS (Remote PHP Vulnerability Scanner)	Осу­щест­вля­ет пол­ное соб­ра­ние лин­ков с сайта, пос­ле че­го под­став­ля­ет спец­симво­лы в пе­ремен­ные и про­водит ана­лиз на по­казан­ных PHP ошиб­ках и сиг­на­турах	РНР	Поз­во­ля­ет на­ходить та­кие у­яз­ви­мос­ти, как XSS, SQL-Injection, у­яз­ви­мос­ти под­клю­чения файлов фун­кци­ями include( ) и fopen( ) и рас­кры­тия ин­стал­ля­ци­он­но­го пу­ти
Qaudit	Про­водит быс­трый ана­лиз ис­ходных файлов на на­личие пе­репол­не­ния бу­фера, оши­бок фор­матной стро­ки, зап­ро­сов ис­полня­емых вы­зовов, пе­ремен­ных сре­ды и фун­кций, име­ющих проб­ле­мы за­щиты	С/С++	На­писа­но на ин­тер­пре­тиру­емом язы­ке Perl, прос­то в ис­пользо­вании
Рос­сийские средс­тва вы­яв­ле­ния у­яз­ви­мос­тей
АК-ВС	Вы­пол­ня­ет ав­то­мати­зиро­ван­ный ана­лиз ис­ходных тек­стов в це­лях вы­яв­ле­ния по­тен­ци­ально опас­ных сиг­на­тур	С/С++, Java, Pascal, C#, PHP, Assembler	Поз­во­ля­ет про­водить ста­тичес­кий ана­лиз ис­ходных тек­стов, ди­нами­чес­кий ана­лиз, име­ет ба­зы сиг­на­тур для каж­до­го из под­держи­ва­емых язы­ков прог­рамми­рова­ния
А­ИСТ-С	Про­водит ав­то­мати­зиро­ван­ный ана­лиз ис­ходных тек­стов	С/С++	Поз­во­ля­ет про­водить ста­тичес­кий ана­лиз ис­ходных тек­стов
КСА­ИТ	Осу­щест­вля­ет ав­то­мати­зиро­ван­ный ана­лиз ис­ходных тек­стов	С/С++	То же
UCA	Вы­яв­ля­ет по­тен­ци­ально опас­ные сиг­на­туры	С/С++, Pascal, Perl, PLM	Име­ет ба­зы сиг­на­тур для каж­до­го из под­держи­ва­емых язы­ков про­грам­ми­рова­ния
Viva64	По­мога­ет от­сле­живать в ис­ходном ко­де по­тен­ци­ально опас­ные фраг­менты, свя­зан­ные с пе­рехо­дом от 32-бит­ных сис­тем к 64-бит­ным	С/С++	По­мога­ет пи­сать кор­рек­тный и оп­ти­мизи­рован­ный код для 64-бит­ных сис­тем
Глав­ные вы­воды о на­личии у­яз­ви­мос­тей в прог­рам­мном про­дук­те де­ла­ет эк­сперт, про­водя­щий тес­ти­рова­ние по тре­бова­ни­ям бе­зопас­ности. Так­же вста­ет важ­ный воп­рос о не­об­хо­димос­ти соз­да­ния стан­дарта тес­ти­рова­ния по тре­бова­ни­ям бе­зопас­ности, в ко­тором бу­дут при­веде­ны спис­ки (ба­зы) по­тен­ци­ально опас­ных сиг­на­тур.
